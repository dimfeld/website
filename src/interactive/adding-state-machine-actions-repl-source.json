[
  {
    "type": "svelte",
    "name": "AddCampaign",
    "source": "<script>\n\timport makeStateMachine from './stateMachine.js';\n\n\texport let searchDelay = 500;\n\texport let submitDelay = 500;\n\texport let searchSucceeds = true;\n\texport let submitSucceeds = true;\n\tlet campaignName = 'a-fake-campaign';\n\n\tconst IDLE='IDLE', SEARCHING='SEARCHING', SEARCH_ERROR='SEARCH_ERROR',\n\t\t\tSEARCH_FOUND='SEARCH_FOUND', SUBMITTING='SUBMITTING', SUBMIT_SUCCEEDED='SUBMIT_SUCCEEDED',\n\t\t\tSUBMIT_ERROR='SUBMIT_ERROR';\n\n\tfunction abortableFakeDelay({delay, succeed, signal, result}) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tvar finish = () => {\n\t\t\t\tif(succeed) {\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else {\n\t\t\t\t\treject(new Error('failed'));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tlet timer = setTimeout(finish, delay);\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\tclearTimeout(timer);\n\t\t\t\treject(new DOMException('aborted', 'AbortError'));\n\t\t\t});\n\t\t});\n\t}\n\n\tconst machineConfig = {\n\t\tinitial: IDLE,\n\t\ton: {\n\t\t\t'search': { target: SEARCHING },\n\t\t},\n\t\tstates: {\n\t\t\t// We start here\n\t\t\t[IDLE]: {},\n\t\t\t// Looking for the campaign the user selected\n\t\t\t[SEARCHING]: {\n\t\t\t\tinvoke: {\n\t\t\t\t\tsrc: (ctx, {data}, {signal}) => abortableFakeDelay({ delay: searchDelay, succeed: searchSucceeds, signal, result: data }),\n\t\t\t\t\tonDone: {\n\t\t\t\t\t\ttarget: SEARCH_FOUND,\n\t\t\t\t\t\taction: (ctx, {data}) => (ctx.currentCampaign = data)\n\t\t\t\t\t},\n\t\t\t\t\tonError: { target: SEARCH_ERROR }\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Couldn't find the campaign\n\t\t\t[SEARCH_ERROR]: {},\n\t\t\t// Found the campaign, so we show the campaign details and an \"Add\" button.\n\t\t\t[SEARCH_FOUND]: {\n\t\t\t\ton: {\n\t\t\t\t\t'submit': { target: SUBMITTING },\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Adding the campaign to the database\n\t\t[SUBMITTING]: {\n\t\t\t\tinvoke: {\n\t\t\t\t\tsrc: (ctx, ev, {signal}) => abortableFakeDelay({ delay: submitDelay, succeed: submitSucceeds, signal, result: null }),\n\t\t\t\t\tonDone: { target: SUBMIT_SUCCEEDED },\n\t\t\t\t\tonError: { target: SUBMIT_ERROR }\n\t\t\t\t},\n\t\t\t\ton: {\n\t\t\t\t\t// Don't start a search while submitting.\n\t\t\t\t\t'search': {},\n\t\t\t\t}\n\t\t\t},\n\t\t\t// It worked!\n\t\t\t[SUBMIT_SUCCEEDED]: {},\n\t\t\t// It didn't work.\n\t\t\t[SUBMIT_ERROR]: {}\n\t\t}\n\t};\n\n\tconst { send, store: machineState } = makeStateMachine(machineConfig, { currentCampaign: null });\n\n\tlet stateChanges = [];\n\n\t$: if(stateChanges[0] !== $machineState.state) {\n\t\tstateChanges = [$machineState.state, ...stateChanges];\n\t}\n</script>\n\n<div>\n\t<div>\n\t\tFake UI Buttons\n\t</div>\n\t<div>\n\t\t<button type=\"button\" on:click={() => send('search', campaignName)}>Search</button>\n\t\t<button type=\"button\" on:click={() => send('submit')}>Submit</button>\n\t</div>\n\n\t<p>\n\t\t<label for=\"campaign-name\">Campaign Name</label>\n\t\t<input id=\"campaign-name\" bind:value={campaignName} />\n\t</p>\n\n</div>\n\n<p>\n\tCurrent state:<br />{$machineState.state}\n</p>\n\n<p>\n\tLoaded Campaign:<br /> {$machineState.context.currentCampaign}\n</p>\n\n<div style=\"height:400px;overflow-y:auto;border:1px solid gray\">\n\t<div>\n\t\t<strong>State History</strong>\n\t</div>\n\t{#each stateChanges as state}\n\t\t<div>{state}</div>\n\t{/each}\n</div>"
  },
  {
    "type": "svelte",
    "name": "App",
    "source": "<script>\n\timport AddCampaign from './AddCampaign.svelte';\n\n\tlet searchDelay = 1000;\n\tlet submitDelay = 1000;\n\tlet searchSucceeds = true;\n\tlet submitSucceeds = true;\n</script>\n\n<div width=\"100%\" style=\"display:flex;flex-direction:row\">\n\t<div style=\"margin-right:1rem\">\n\t\t<AddCampaign bind:searchDelay bind:submitDelay bind:searchSucceeds bind:submitSucceeds />\n\t</div>\n\n\t<div>\n\t<div>\n\t\tInternal Details\n\t</div>\n\n\t<p>\n\t\t<label for=\"search-delay\">Search Delay</label>\n\t\t<input id=\"search-delay\" type=\"number\" bind:value={searchDelay} />\n\t</p>\n\n\n\t<p>\n\t\t<label style=\"display:inline\" for=\"submit-succeeds\">Search Succeeds</label>\n\t\t<input id=\"search-succeeds\" type=\"checkbox\" bind:checked={searchSucceeds} />\n\t</p>\n\n\t<p>\n\t\t<label for=\"submit-delay\">Submit Delay</label>\n\t\t<input id=\"submit-delay\" type=\"number\" bind:value={submitDelay} />\n\t</p>\n\n\t<p>\n\t\t<label style=\"display:inline\" for=\"submit-succeeds\">Submit Succeeds</label>\n\t\t<input id=\"submit-succeeds\" type=\"checkbox\" bind:checked={submitSucceeds} />\n\t</p>\n\n\t</div>\n</div>"
  },
  {
    "type": "js",
    "name": "stateMachine",
    "source": "import { writable } from 'svelte/store';\n\nexport default function(machineConfig, initialContext) {\n\tlet currentState = machineConfig.initial;\n\tlet currentAbortController;\n\tlet context = initialContext;\n\n\tlet _store = writable({ state: currentState, context })\n\n\tfunction runTransition(stateInfo, transition, eventData) {\n\t\tlet targetState = transition.target;\n\n\t\tif(targetState) {\n\t\t\tif(currentAbortController) {\n\t\t\t\t// We're transitioning to another state, so try to abort the action if\n\t\t\t\t// it hasn't finished running yet.\n\t\t\t\tcurrentAbortController.abort();\n\t\t\t}\n\n\t\t\t// Run the exit action\n\t\t\tif(stateInfo.exit) {\n\t\t\t\tstateInfo.exit(context, eventData);\n\t\t\t}\n\t\t}\n\n\t\t// Run the transition's action, if it has one.\n\t\tif(transition.action) {\n\t\t\ttransition.action(context, eventData);\n\t\t}\n\n\t\tif(!targetState) {\n\t\t\t// If the transition has no target, then it's just an action, so return.\n\t\t\t_store.set({ state: currentState, context });\n\t\t\treturn;\n\t\t}\n\n\t\t// Update the state if the transition has a target\n\t\tcurrentState = targetState;\n\n\t\t// And then run the next state's entry action, if there is one.\n\t\tlet nextStateInfo = machineConfig.states[currentState];\n\t\tif(nextStateInfo.entry) nextStateInfo.entry(context, eventData);\n\n\t\t// Run the asynchronous action if there is one.\n\t\tlet asyncAction = nextStateInfo.invoke;\n\t\tif(asyncAction) {\n\t\t\t// Create a new abort controller and save it.\n\t\t\tlet abort = currentAbortController = new AbortController();\n\t\t\tasyncAction.src(context, eventData, abort)\n\t\t\t\t.then((result) => {\n\t\t\t\t\t// If the request aborted, ignore it. This means that another event\n\t\t\t\t\t// came in and we've already transitioned elsewhere.\n\t\t\t\tif(abort.signal.aborted) { return; }\n\n\t\t\t\t\t// Run the success transition\n\t\t\t\t\tif(asyncAction.onDone) {\n\t\t\t\t\t\trunTransition(nextStateInfo, asyncAction.onDone,\n\t\t\t\t\t\t\t{ event: 'invoke.onDone', data: result });\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch((e) => {\n\t\t\t\t\tif(abort.signal.aborted) { return; }\n\n\t\t\t\t\t// Run the failure transition\n\t\t\t\t\tif(asyncAction.onError) {\n\t\t\t\t\t\trunTransition(nextStateInfo, asyncAction.onError,\n\t\t\t\t\t\t\t{ event: 'invoke.onError', data: e });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\n\t\t_store.set({ state: currentState, context });\n\t}\n\n\treturn {\n\t\tstore: _store,\n\t\tsend(event, data) {\n\t\t\tlet stateInfo = machineConfig.states[currentState];\n\n\t\t\tlet next = (stateInfo.on || {})[event];\n\t\t\tif(!next) {\n\t\t\t\t// No transition for this event in the current state. Check the global handlers.\n\t\t\t\tnext = machineConfig.on[event];\n\t\t\t}\n\n\t\t\tif(!next) {\n\t\t\t\t// No global handler for this event, and no handler in the current state, so ignore it.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trunTransition(stateInfo, next, { event, data });\n\t\t},\n\t}\n}"
  }
]
