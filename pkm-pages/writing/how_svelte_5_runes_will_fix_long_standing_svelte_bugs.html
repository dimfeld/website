---
title: "How Svelte 5 Runes will Fix Long-Standing Svelte Bugs"
tags: Svelte
date: 2023-09-30
updated: 2023-10-01
draft: false
---


    
    <p>Svelte 5&#39;s rune system has brought a lot of excitement, but also some consternation. While overall it&#39;s a big improvement, certain patterns seem like they&#39;ll be less ergonomic, and Svelte may feel less &quot;magical&quot; than it used to.</p>
    <p>As it&#39;s still in progress, hopefully some of these concerns will be alleviated as runes are refined and best practices are established. But the biggest improvement IMO will be that some long-standing, hard-to-fix bugs in Svelte will be gone.</p>
    <h2>Large Svelte Apps</h2>
        <p>Many people may not experience these bugs, as they only show up with more complex code. So first, a bit about my experience. The Carevoyance SvelteKit app contains over 600 individual Svelte components and a bunch of supporting Javascript code. The app originated in 2014 and was initially written in AngularJS (aka Angular 1). Svelte came onto my radar just after Svelte 3 was released, and after some prototyping, it was clear that the move to Svelte would be a huge improvement. The ability to easily integrate Svelte into the existing Angular app, and to somewhat easily render Angular templates from Svelte, also made the migration much easier.</p>
        <p>Of course, nothing is perfect, and we did hit a few wrinkles that even now aren&#39;t fixed in Svelte 4. But they will be in 5! Let&#39;s take a look.</p>

    <h2>Loss of Reactivity with Multiple Nested Slots</h2>
        <p>There are a few Github issues about this one already, and unfortunately it looks very tricky to fix. In Svelte 3.12, the state tracking system was updated to use a &quot;dirty&quot; bitset, where each number in the bitset corresponded to a particular variable which some reactive code or template reference depends on. This brought a much needed performance increase, but also leads to complexity when using slots.</p>
        <p>When using slots, Svelte passes a portion of its dirty bitset from the parent component into the child, so that the child will know when to rerender the slot. This usually works well, but sometimes when using nested components with multiple layers of slots, something gets lost. Changes aren&#39;t reflected immediately, sometimes being a tick behind or lost completely.</p>
        <p>These REPLs demonstrates the problem in Svelte 3 and 4:</p>
        <p><a href="https://svelte.dev/repl/39bafbb43d2a44af874156720f6e1cad?version=3.50.1">REPL 1</a></p>
        <p><a href="https://svelte.dev/repl/82ea195768214f75b408409b12e26e01?version=4.2.0">REPL 2</a></p>
        <p>(I didn&#39;t write these; they came from the authors of various Github issues).</p>
        <p>Svelte 5&#39;s rune system completely changes how this works. The code generated by the compiler plays much less of a role in dependency tracking now. Instead each rune tracks everything that depends on it and this works across modules. This also means that slots are vastly simplified, with no more need to pass a subset of the dirty bitset between components.</p>
        <p>Below I&#39;ve ported the above REPLs to Svelte 5. Notice that everything works!</p>
        <p><a href="https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAE6WUW2_TMBTHv8oh4qGbRrys3cZCWwQPICSEEONt2UManzRmqW3Z7mWq-t2x4yRLtNKtQsrNzrn4nP_P3gY5K1EH8d024OkCgzj4JGVwFphH6QZ6haVBO9ZiqTI3M9aZYtJME54YcuqeifldMA32SkEKZUDkUBgjdUyI9w8prohCWZLhzSzNZ7PRkF6ko1Gav78eRZdX1xfn-RVGWUo_rlBpJvhkGF6eh5ELD7AuWFbAOtWwVswY5GAEUFwIro1KDbbZ5swUy1mYiUWd-I-uPwjTeomaXN9EwzDhcEpcaLao1vtZbL4qsZSQK7GAJAhJMxN67yToWN8alNGTaTXs2bm7RAPa_tEwgbfa2EUO7nyvtlmB2QPSGPK01Lg7O376_uRDwsfkSQg-LqJKkG8ccGN7AroUBgbcPtZCPTA-P3EeldW4Ka7yGPtyZozTuFrwZFu9dkCcLekat2l-iF6a5ykOBLUsLQRlOUMaxEYtbU0tejbZa9F7ku62SKlY97TzUx1R-s1qLXwHKFtZrR5LnCSBTCm1pcQQ4SIJpl6EcVUm8dbEmk-dyGPSj_NCYVUXD1fns7wQ56cSc4VaH9-oXov2kf3KZrriARzh25rxnaNcKiH1wKHZ2wDfMTfuN0XFVkgH1WRoTx2DqhrAZApv3EdYs34SlsjnpnhOuUf2F6aZsbFALI1mFGPYtpl2zkW2MnvJZK1j68j4Hj-nbW3Ju5pXOu8F57i4XV5e0NhbHVS4C-1MbN7pyiWGS7np3jXD3Wocv4fyV3v3eLoaLnvsNJN7z8d_0PNsr7aR60PEV1SmMyybDcq4XBpwK7btqDCyPUkCfwLVWNVn0N35fQPart7TifnClPaykzqu-b8k0Z4kt5gJTntZPBRNgXtkud_9BR3AKq6iBwAA">REPL 1, Svelte 5 version</a></p>
        <p><a href="https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAE8VU3W7aMBR-laOoUpMWJcBoSxlkarIHmLTeLbswyUnjLdiR7YAmxP1u-wR7xT3CbKeQQClCvZkEiY9zvu_8n7WT0xKlM_m2dhhZoDNxHqrK6TnqV2UEucRSoZYlr0VqbqYyFbRSYcISFVyZZ6IeCypB_whUXCjgORRKVXISBA3ez3AZCKzKYDxEMri_ubsdDwej_O5mPuqPR_37-WCIw1vsDz4tUUjK2WzkD_2-YQdYFTQtYEUkrARVChkoDhkuOJNKEIU7Y09UFfXcT_nixe4P-XIIqJQ1yuB-cDv2EwZXgX4AXVh3Y67fDJl6gFzwBSSOH7R3fsOQOB-PQaIjkOg0JD4CibsQAypRQUYUgRlcSKWDdNfmGqASvHqYwOVlr5WjAznW8lyQornbeB3OJSlr_GxYMxR0iZlrrPiWFa5hJ8QGNA3aWrNpRpdhozeDKWVVrWBOWTaxlLN1y7OBIIS_f55_fymRSIS6ymyVUKCpnER95iugClZc_JT-NDDUHQuRtpA4LWO0SZxXSvGBUnyotAvVOnXdwTRfOvoaUYjQotrC78g6_WGp9mO1ObBezroeh9NOD71hIgKXoVSYgSy5kt5ri1FoCrcX86nUxyb1W5YX3BlpsMV6LHDbHbZSepwZVyCQpEo3CriUwVfbpPABCMtg5LWVC_Y8PhZr_Dq4-L8Gtw3sWBDGM73zFjyjOcXMmShR46a3W5FtZc_dlGb21o2XvWZmYWOm0Byl69lFYf55zbRXnEFaEPaELvGgM_hmMIid6UY_UReY55gq1_VgFm5B1ox3eoJ1ipoGPjJaUfu9O3pnZSQ6LyPvWIv7sRx2kZkg3R_vK2N80uldx3VsvJWR75t_pecaLFIHAAA=">REPL 2, Svelte 5 version</a></p>

    <h2>Hidden Circular Dependencies can Lose Updates</h2>
        <p>This one is due to a combination of how Svelte topologically sorts things, and how the &quot;dirty&quot; bitset is managed.</p>
        <p>As described above, Svelte components set a bit in their dirty bitset when a store or other reactive dependency changes, and this normally would cause any statements that rely on that store to rerun. But at the end of running a component&#39;s reactive statements, Svelte clears out the entire bitset. Normally this prevents infinite loops if a statement both reads and writes the same value, and Svelte&#39;s reordering of reactive statements in causal order makes everything work fine.</p>
        <p>The bug here occurs when a component calls a function in some external code which updates a store, and some other reactive statements in the component also rely on that store.</p>
        <p>Let&#39;s say reactive statement A is the one that calls the external function, and statement B is the one that reads from the store that the external function updates.</p>
        <p>Since this chain of causality isn&#39;t wholly inside a single component, Svelte doesn&#39;t know that it needs to place B after A &mdash; their order in the component may be related to other dependencies, but the causal link from the store is not considered.</p>
        <p>There&#39;s also a luck factor here, since the relative placement of the two statements in the compiled code can affect if the bug occurs. I&#39;ve seen cases where trivial changes like switching how we wrote an if statement, or merging two reactive statements into one, was enough to cause the bug to occur or go away.</p>
        <p>This is difficult to replicate in a simple REPL, but it happens most often with complex layouts that have a set of components and some shared state between them.</p>
        When you get lucky with the order of the compiled output statements, the process is something like this:
          <ol class="list-bullet">
            <li>Reactive statement &quot;A&quot; runs, and calls the external function, which then updates the store.</li>
            <li>The listener in the Svelte component runs and updates <code>$store</code>, using the internal invalidate function to set the bit in the dirty bitset.</li>
            <li>Reactive statement &quot;B&quot; that depends on <code>$store</code> is checked. It runs because the store was updated.</li>
            <li>This cycle of running reactive code ends, so Svelte clears the bitset.</li>
          </ol>
        But if the two reactive statements are swapped, the order of events is something like this:
          <ol class="list-bullet">
            <li>Reactive statement &quot;B&quot; that depends on <code>$store</code> is checked. It doesn&#39;t run because the store wasn&#39;t updated.</li>
            <li>Reactive statement &quot;A&quot; runs, and calls the external function, which then updates the store.</li>
            <li>The listener in the Svelte component runs and updates <code>$store</code>, using the internal invalidate function to set the bit in the dirty bitset.</li>
            <li>This cycle of running reactive code ends, so Svelte clears the bitset.</li>
            <li>Statement &quot;B&quot; is not immediately run again, and so the values that it computes become out of sync. </li>
          </ol>
        <p>Keep in mind that you have no control over the order in which A and B run, at least with regard to the store&#39;s value.</p>
        <p>The way to work around this is to wait a <code>tick</code> somewhere in the chain, so that the store&#39;s update doesn&#39;t happen until after the current reactive cycle ends. But this solution is usually only reached after a long period of tricky debugging and walking through both the compiled output and internal Svelte code to see what&#39;s happening.</p>
        <p>The good news again is that Svelte 5 will fix this, and for the same reasons mentioned in the previous section. The compiler is not reordering statements anymore, nor does the compiler try to figure out which statements should run when; it&#39;s all done at runtime instead in a fashion that works fine with cross-module reactivity.</p>

    <h2>The Upshot</h2>
        <p>Svelte 5&#39;s runes system ultimately moves a lot of the state-tracking complexity out of the compiler and into the runtime. Not only does this fix the above bugs, but it will make it much easier to test and verify this code without the need to convince the compiler to generate various edge cases. It should be quite feasible to use more advanced testing methodologies such as model-based testing too, should the need arise.</p>
        <p>I do agree that there are some ergonomic questions remaining with Svelte 5. How will it work to edit complex nested objects? Will we constantly write lots of boilerplate to add accessors to things? Fortunately the Svelte team is listening to the community&#39;s concerns, and I believe that the final release of Svelte 5 will be a good experience for the developer, even if it&#39;s not quite as magical as Svelte 4. But being able to write bug-free code is paramount.</p>
        <p>Three years ago, <a href="https://www.twitter.com/swyx">@swyx</a> wrote, <a href="https://www.swyx.io/svelte-sites-react-apps">Svelte for Sites, React for Apps</a>. I don&#39;t know if he still stands by those words as Svelte and its ecosystem have come a long way since then (and Shawn has been a big part of that!), but I do think that Svelte 5 will allow us to be more confident in saying &quot;Svelte for Sites, and Svelte for Apps!&quot;</p>




