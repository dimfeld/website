---
title: Reading the "CRDTs for Mortals" Example Code
date: 2020-09-03
tags: CRDTs, state
---

I recently watched [CRDTs for Mortals](https://www.dotconferences.com/2019/12/james-long-crdts-for-mortals) by James Long, in which he details how he designed the "local-first" data management for his personal finance application.

The whole idea of this is that you shouldn't need to constantly have an internet connection to have a good experience using the application. Multiple applications can work with the same data and sync them only occasionally, accounting for possibly long periods of offline work in which syncing can not be done.

It's a huge pain to manually write conflict-resolution code. Even if it appears simple at first, more and more edges cases will appear and almost certainly cause bugs and lost or incorrect data. So we need some data structures to facilitate safe syncing without needing to reimplement a new, bespoke version of this code every time.

This is what James describes in his talk, and he graciously also provided an [example application](https://github.com/jlongster/crdt-example-app/) that implements this type of code.

> Note: I've been familiar with the basics of CRDTs for a while, so if I appear to skip over any basic concepts here it was not intentional. Please [let me know](https://www.twitter.com/dimfeld) if something is confusing and I can add more detail.

# CRDTs

The data is represented as a bunch of "conflict-free replicated data types," or CRDTs. A CRDT has a few important properties when being applied to the data:

- It is commutative, which means that (like addition or multiplication) it doesn't matter which one comes first. A + B + C has the same result as C + B + A.
- It is idempotent, which means that applying a CRDT that has already been applied to the state will not change the state again.

Essentially, this means that we can apply a CRDT to our state without needing to do any special checking of if we've seen that operation already, or needing to figure out how it interacts with other operations that we may have applied before seeing this one. The CRDT code handles those details for us, so sync operations can just apply anything coming in from the sever and it will work correctly.

# Logical Clocks

> Implemented at [timestamp.js](https://github.com/jlongster/crdt-example-app/blob/master/shared/timestamp.js)

Logical clocks are used to create an agreed-upon ordering of events without the need for a central clock. The logical clock system is a pretty standard "unique time stamp" implementation. Each time stamp is made up of three parts:

1. The "wall clock" time with millisecond precision.
2. A "logical time" counter that starts at 0. If the physical time is the same as the previous generated timestamp, the counter increments. Otherwise it is set back to 0.
3. The node ID, which is usually a UUID generated by the client.

## Pitfalls

One problem with using wall-clock time to order time stamps is if one of the clients sets its clock in the future. Effectively, any changes by that client will be permanent until the date in the timestamp has passed; changes from any other client will be ignored because their timestamps are smaller.

You could fix this by setting the server to reject commands with a time stamp too far in the future. This can also be ameliorated somewhat by occasionally querying the server for its idea of the current time, and correcting the local time stamps that way.

Another way is to just use purely logical clocks such as a [Lamport timestamp](https://en.wikipedia.org/wiki/Lamport_timestamp), though that complicates things somewhat compared to this implementation, and works better when nodes won't potentially be offline for significant periods of time.


# Merkle Tree

> Implemented at [merkle.js](https://github.com/jlongster/crdt-example-app/blob/master/shared/merkle.js)

A [merkle tree](https://en.wikipedia.org/wiki/Merkle_tree) is maintained alongside the state, and used to facilitate syncing. It provides a relatively quick way to see if two versions of the state are the same, and if not, where the earliest divergence takes place.

This implementation is a ternary trie. Each key uses a base 3 timestamp with minute resolution for its keys. The value is the hash of the entire timestamp (clock time, logical time, and node ID).

Each node contains a hash value that is an XOR of the hashes of all the writes that have happened on that timestamp. When adding a new node, the write process walks down the tree and XORs its timestamp along the way into each node it traverses.

When syncing, we compare the client’s tree with the server’s tree and look for the first timestamp with a differing hash, and this gives us a lower bound on the messages that need to be synced.

# Data Format

This application uses two CRDT types: A grow-only set and a last-write-wins (LWW) map.

The set contains all the CRDT commands that have come in. Each command in the set is a write to one of the maps.

A command lists the table, the row ID, the column, and the value to write. If the timestamp is greater than the latest seen timestamp for that table/row/column, then the write takes effect. Otherwise it is ignored.

This works well for structured data. It probably doesn't work well for collaborative editing of prose where you want edits to the same areas to be combined rather than last-write-wins.

# Applying Messages

> Implemented at [sync.js](https://github.com/jlongster/crdt-example-app/blob/3acd31069db65607bacd88a71c89fb43e53b6ec8/client/sync.js#L70)

Reading through your entire set of CRDTs every time you want to read your state is not very efficient, so this implementation materializes the CRDTs into a snapshot of the latest state as messages arrive.

The example app's implementation in intentionally inefficient in favor of being simple and understandable.

Every time a batch of messages comes in, it sorts the existing messages by timestamp and finds the latest message corresponding to the same location as each incoming message.
Then for each incoming message it compares the timestamp of the latest message to the new message. If the incoming message is newer or there is no match, it applies the message.
It also hashes every non-duplicate message into the merkle tree. This allows consistency checking and also speeds up the sync process after being offline.

# Client Database Implementation

> Implemented at [db.js](https://github.com/jlongster/crdt-example-app/blob/master/client/db.js)

Writing to the database actually takes the form of sending messages into the sync engine, which sends the messages to the server and also applies the added messages just like any other received message.

Like other CRDT systems, deletes are handled by setting a value in a tombstone column. Reading is just reading like normal, except that you need to check that the the tombstone column is not set.

# Server Implementation

> Implemented at [server/index.js](https://github.com/jlongster/crdt-example-app/blob/3acd31069db65607bacd88a71c89fb43e53b6ec8/server/index.js#L97)

The server has a database that stores both the messages and the merkle trees. Messages are namespaced so that there can be multiple copies of the state for each one. A namespace might be an account ID, for example. Each namespace has its own merkle tree.

The server has a single useful endpoint, `/sync`, which handles both sending and receiving messages. Every message that comes in and hasn't been seen before goed into the database and into the merkle tree.

When the server syncs messages down to a client, it compares the client’s merkle tree with its own to find the earliest timestamp that differs, and sends all the messages since that timestamp.

# Questions

These questions apply more to scaling real implementations of CRDT-based state than to this particular example.

Are there performance implications to sending the entire Merkle tree on every sync request? I'm guessing that it takes a while before this becomes an issue but eventually it could.

Same question for the number of CRDT operations growing since the set of operations never shrinks.

I believe some implementations tackle this through some sort of "convergence" of the state that it knows all possible clients will have. So CRDTs before a certain timestamp are all merged into a single base state object and then the additional CRDTs after this are applied upon that base state.
Deciding when to do this and where to set that minimum timestamp are, of course, significant challenges. You probably have to reject any updates that come in for timestamps before that time, and tell clients that you inadvertently missed to just drop their changes and update to the latest state.

