---
title: Starting with Solana, Part 4
summary: A TODO List with Rewards
frontPageSummary: creating an incentivized TODO list
date: 2021-10-29
tags: Solana, Svelte, web3, cryptocurrency
---

In [part 3](starting_with_solana_part03) we looked at testing and deploying our Solana program. I was going to put
together an article about using Svelte with Solana for part 4, but that will wait for part 5 instead while we focus on
making a more interesting on-chain program -- a todo list where anyone can add an item and attach a reward for
completion.

# Program-Derived Accounts

With this program, each todo list is a Solana account, and each item in the list is also an account. Anyone can add an item, and the reward will be
applied to the list owner's account when both the list owner and the item creator mark it finished.

Normally, to use such a list you would need to know two public keys, one for the list's owner and another for the list
itself. But Solana lets us use [program derived
addresses](https://docs.solana.com/developing/programming-model/calling-between-programs#program-derived-addresses)
(PDAs) as a
better solution. These addresses are calculated from a hash of the program ID and various "seed" values which can include
public keys or other strings of bytes, up to 32 bytes each.

::: note

Don't worry if this seems complex right now. PDAs are a big part of Solana, but once we use them below it will make more
sense.

:::


Solana also requires that program derived addresses can not have an associated private key, and it enforces this by
checking that that they are not valid values on the [ed25519 elliptical curve](https://en.wikipedia.org/wiki/EdDSA) used
to generate keys. After calculating the hash above, a "bump" value is added to the hash until a value is found that is
not on the curve. This bump starts at 255 and is decremented until it finds a value not on the curve, and that
becomes the actual address.

It's not guaranteed that this bump process will generate a valid PDA, but the chances are very high. And since the
address is not a real public key, it's guaranteed that the program from which the PDA came is the only thing that can
generate a signed transaction from it.

# The Program

Our program will have four instructions to manage a list and its items:

- NewList to make a new todo list.
- Add to add an item to a list.
- Cancel to delete an item, unfinished.
- Finish to mark an item and reward the bounty when both the list's owner and the item's creator agree it's finished.

::: warn

The Finish instruction's escrow mechanism is intentionally simple to avoid overloading this post with new information.
Real programs would want to use something more secure. [paulx's blog](https://paulx.dev/blog/2021/01/14/programming-on-solana-an-introduction/)
has a thorough explanation of how to do it right.

:::

# Test Infrastructure

TODO

# Creating a List

Any user can run the `NewList` instruction to create a new todo list. The `TodoList` account structure holds all the
information for a list, including the list's owner and name, how many items it can hold, and references to the accounts
for each item in the list. Finally it also holds the bump value that was used to calculate its PDA, which feeds into
Anchor's autogenerated verification processes.

## TodoList Data Structure

```rust
#[account]
pub struct TodoList {
    pub list_owner: Pubkey,
    pub bump: u8,
    pub capacity: u16,
    pub name: String,
    pub lines: Vec<Pubkey>,
}
```

We also add a function to calculate the space needed for a TodoList structure. We could do this all
within Anchor's `account` macro but this is much easier to manage. Remember that accounts that don't have any
dynamically-sized data (Strings or Vecs) can just `#[derive(Default)]` to have Anchor automatically calculate the
size.

```rust
impl TodoList {
    fn space(name: &str, capacity: u16) -> usize {
        // discriminator + owner pubkey + bump + capacity
        8 + 32 + 1 + 2 +
            // name string
            4 + name.len() +
            // vec of item pubkeys
            4 + (capacity as usize) * std::mem::size_of::<Pubkey>()
    }
}
```

## NewList Accounts

There's a lot going on in the `#[account]` macro for the NewList instruction so we'll go over them one by one.

```rust
fn name_seed(name: &str) -> &[u8] {
    let b = name.as_bytes();
    if b.len() > 32 { &b[0..32] } else { b }
}

#[derive(Accounts)]
#[instruction(name: String, capacity: u16, list_bump: u8)]
pub struct NewList<'info> {
    #[account(init, payer=user,
      space=TodoList::space(&name, capacity),
      seeds=[
        b"todolist",
        user.to_account_info().key.as_ref(),
        name_seed(&name)
      ],
      bump=list_bump)]
    pub list: Account<'info, TodoList>,
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

The `#[instruction]` macro tells Anchor to deserialize the instructions inside the autogenerated code so that
the rest of the `#[account]` macros here can use their values. Note that Anchor doesn't verify that the
arguments listed in `#[instruction]` actually match the arguments in the implementation function.

- `init` and `payer` are the same as before -- they tell Anchor to create the specified account and who should
pay for it.
- `space` just calls `TodoList::space`, which we wrote above.
- `seeds` tells Anchor that this account is a PDA and lists the seed values which are hashed to calculate it. Anchor
    recalculates the PDA to ensure that the passed-in value is valid. Each seed value can be no more than 32 bytes,
    so we write a `name_seed` helper function to handle that.
- `bump` is also used by Anchor's PDA code so that it can calculate and verify the PDA without needing to manually
calculate `bump` through the "check and decrement" loop, which can be costly when operating under Solana's strict
computation budget. In most cases the caller initially generates the PDA and finds a proper bump value, since it tends
to be operating in an environment where an extra `for` loop doesn't matter much.

## NewList Implementation

Finally, we write the actual implementation. Not much to do here; we just copy the instruction's arguments
into the TodoList data structure.

```rust
#[program]
pub mod todo {
    pub fn new_list(
        ctx: Context<NewList>,
        name: String,
        capacity: u16,
        account_bump: u8,
    ) -> ProgramResult {
        // Create a new account
        let list = &mut ctx.accounts.list;
        list.list_owner = *ctx.accounts.user.to_account_info().key;
        list.bump = account_bump;
        list.name = name;
        list.capacity = capacity;
        Ok(())
    }
}
```

## Testing List Creation

# Adding an Item

Any user can call the `Add` instruction on anyone else's todo list. The arguments are the item name and the number of tokens for the item bounty. The account's
pubkey will also be added to the main todo list account.

## ListItem Data Structure

Each list item keeps track of who created it and who has marked it finished. The reward amount is just the balance on
the account, so we don't need to explicitly track it here. As before, there's a `space` function to better colocate
the space calculation with the actual list of fields.

```rust
#[account]
pub struct ListItem {
    pub creator: Pubkey,
    pub creator_finished: bool,
    pub list_owner_finished: bool,
    pub name: String,
}

impl ListItem {
    fn space(name: &str) -> usize {
        // discriminator + creator pubkey + 2 bools + name string
        8 + 32 + 1 + 1 + 4 + name.len()
    }
}
```

## Add Accounts

Once again, the `list` account includes the necessary `seeds` and `bump` to verify the PDA. We also
pass the list owner's pubkey and the list name to assist in verifying the PDA address. The `item`
account initializes the new list with enough space to hold the name and other data.

```rust
#[derive(Accounts)]
#[instruction(list_name: String, item_name: String, bounty: u64)]
pub struct Add<'info> {
    #[account(
      mut,
      has_one=list_owner @ TodoListError::WrongListOwner,
      seeds=[
        b"todolist",
        list_owner.to_account_info().key.as_ref(),
        name_seed(&list_name)
      ],
      bump=list.bump)]
    pub list: Account<'info, TodoList>,
    pub list_owner: UncheckedAccount<'info>,
    // 8 byte discriminator,
    #[account(init, payer=user, space=ListItem::space(&item_name))]
    pub item: Account<'info, ListItem>,
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

## Add Implementation

The add function both adds the new item to the list and attaches the reward amount to the item.

```rust
pub fn add(
    ctx: Context<Add>,
    _list_name: String,
    item_name: String,
    bounty: u64,
) -> ProgramResult {
    let user = &ctx.accounts.user;
    let list = &mut ctx.accounts.list;
    let item = &mut ctx.accounts.item;

    // Check that the list isn't already full.
    if list.lines.len() >= list.capacity as usize {
        return Err(TodoListError::ListFull.into());
    }

    list.lines.push(*item.to_account_info().key);
    item.name = item_name;
    item.creator = *user.to_account_info().key;

    // Move the bounty to the account. We account for the rent amount
    // that the account init already transferred into the account.
    let account_lamports = **item.to_account_info().lamports.borrow();
    if bounty < account_lamports {
        return Err(TodoListError::BountyTooSmall.into());
    }

    let transfer_amount = bounty - account_lamports;
    if transfer_amount > 0 {
        invoke(
            &transfer(
                user.to_account_info().key,
                item.to_account_info().key,
                transfer_amount,
            ),
            &[
                user.to_account_info(),
                item.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
            ],
        )?;
    }

    Ok(())
}
```

Anchor initializes an account with enough lamports to mark the account as rent-exempt, so we calculate
how many more lamports should be transferred to equal the total reward amount, and 
[`invoke`](https://docs.rs/solana-sdk/1.8.2/solana_sdk/program/fn.invoke.html) the
[`transfer`](https://docs.rs/solana-sdk/1.8.2/solana_sdk/system_instruction/fn.transfer.html)
instruction on the system program to do it.

## Testing Item Addition


# Cancelling an Item

Either the TODO list's owner or the creator of an item can cancel the item, in which case the bounty is returned to the item's creator.

## Cancel Instruction Accounts

## Cancel Implementation

## Testing Cancellation


# Finishing an Item

The Finish instruction awards an item's bounty when both the item creator and the list owner mark it finished.

## Finish Instruction Accounts

## Finish Implementation

## Testing Finish
